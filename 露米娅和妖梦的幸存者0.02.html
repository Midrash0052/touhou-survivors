<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>东方生存：妖梦增强版</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #111;
            font-family: 'Microsoft YaHei', sans-serif;
            color: white; user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box; z-index: 5;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.6) 100%);
            pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 4;
        }

        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 20;
            mix-blend-mode: exclusion;
        }

        .hud-top { display: flex; justify-content: space-between; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px black; }
        .exp-bar-container {
            width: 100%; height: 20px; background: #333; border: 2px solid #fff;
            border-radius: 10px; margin-top: 10px; overflow: hidden;
        }
        .exp-bar-fill { height: 100%; background: linear-gradient(90deg, #ff00cc, #33ccff); width: 0%; transition: width 0.1s; }

        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        
        .char-select-container { display: flex; gap: 30px; margin-bottom: 30px; }
        .char-card {
            width: 240px; padding: 20px; border: 2px solid #555; border-radius: 15px;
            background: #222; cursor: pointer; text-align: center; transition: 0.3s;
        }
        .char-card:hover { transform: scale(1.05); border-color: #ffcc00; background: #333; }
        .char-desc { font-size: 12px; color: #aaa; text-align: left; margin-top: 10px; line-height: 1.4; }
        
        #upgrade-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #222, #444);
            border: 2px solid #888; border-radius: 8px; padding: 15px;
            cursor: pointer; text-align: center; transition: 0.2s;
            display: flex; flex-direction: column;
        }
        .upgrade-card:hover { transform: translateY(-5px); border-color: gold; box-shadow: 0 0 15px gold; }

        #ult-text {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'KaiTi', serif; font-size: 80px; color: white;
            text-shadow: 0 0 20px #fff, 4px 4px 0px #000;
            pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 8; white-space: nowrap;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="flash-overlay"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">Score: 0</div>
            <div id="level-display">Lv. 1</div>
        </div>
        <div class="hud-bottom">
            <div style="margin-bottom: 5px; font-size: 20px;">HP: <span id="hp-text">10/10</span></div>
            <div class="exp-bar-container"><div class="exp-bar-fill" id="exp-bar"></div></div>
        </div>
    </div>

    <div id="ult-text">人鬼「未来永劫斩」</div>

    <div id="char-select-screen" class="screen-overlay">
        <h1 style="color:white; font-size:40px; margin-bottom:30px;">选择角色</h1>
        <div class="char-select-container">
            <div class="char-card" onclick="selectCharacter('rumia')">
                <h2 style="color:#ff3333">露米娅</h2>
                <p>BGM: 妖魔夜行</p>
                <div class="char-desc">
                    <b>宵暗槽 (红条):</b> 攻击积攒。<br>
                    <b>J键 (20点):</b> 消耗宵暗，秒杀面前单位并回血。<br>
                    <b>满槽 (100点):</b> 自动触发黑暗力场10秒。
                </div>
            </div>
            <div class="char-card" onclick="selectCharacter('youmu')">
                <h2 style="color:#00ffaa">魂魄妖梦</h2>
                <p>BGM: 广有射怪鸟事</p>
                <div class="char-desc">
                    <b>被动:</b> 受伤触发全屏时缓+无敌反击。<br>
                    <b>时髦值 (蓝条):</b> 静止增加，移动减少。<br>
                    <b>J键 (60-99):</b> 开启剑气波模式。<br>
                    <b>J键 (100):</b> 全屏秒杀。
                </div>
            </div>
        </div>
    </div>

    <div id="upgrade-screen" class="screen-overlay hidden">
        <h2 style="color: gold; margin-bottom: 20px; font-size:30px;">LEVEL UP!</h2>
        <div id="upgrade-container"></div>
    </div>

    <div id="game-over-screen" class="screen-overlay hidden">
        <h1>满身疮痍</h1>
        <p id="final-score" style="font-size: 24px; color:#ddd;">Score: 0</p>
        <button onclick="location.reload()" style="padding:10px 30px; font-size:20px; margin-top:20px; cursor:pointer;">返回标题</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx; let masterGain;
    
    const NOTES = { 'Bb3': 233.08, 'B3': 246.94, 'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'Eb4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'Ab4': 415.30, 'A4': 440.00, 'Bb4': 466.16, 'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'Eb5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'Ab5': 830.61, 'A5': 880.00, 'Bb5': 932.33, 'B5': 987.77, 'C6': 1046.50, 'D6': 1174.66, 'Eb6': 1244.51 };
    const MELODY_RUMIA = ['B4',0.5,'C#5',0.5,'D5',0.5,'C#5',0.5,'B4',0.5,'F#4',1.0,'G4',0.5,'F#4',0.5,'E4',0.5,'F#4',0.5,'G4',0.5,'A4',0.5,'B4',0.5,'C#5',0.5,'D5',0.5,'C#5',0.5,'B4',0.5,'F#4',1.0,'G4',0.5,'F#4',0.5,'E4',0.5,'D4',0.5,'C#4',0.5,'F#4',0.5,'B4',0.5,'C#5',0.5,'D5',0.5,'E5',0.5,'F#5',1.5,'D5',0.5,'C#5',0.5,'B4',0.5,'A4',0.5,'B4',1.5,'Rest',0.5];
    const MELODY_YOUMU = ['F4',0.25,'C5',0.25,'F5',0.25,'Ab5',0.25,'G5',0.25,'Ab5',0.25,'G5',0.25,'Eb5',0.25,'F5',0.5,'C5',0.25,'Bb4',0.25,'Ab4',0.5,'Bb4',0.25,'C5',0.25,'F4',0.25,'C5',0.25,'F5',0.25,'Ab5',0.25,'G5',0.25,'Ab5',0.25,'Bb5',0.25,'Ab5',0.25,'G5',0.5,'Eb5',0.5,'F5',1.0,'Rest',0.5];

    class MusicPlayer {
        constructor() { this.isPlaying = false; this.currentIndex = 0; this.nextNoteTime = 0; this.melody = []; this.tempo = 120; this.oscillatorType = 'square'; this.timerID = null; }
        play(char) { if(this.isPlaying)this.stop(); this.melody=(char==='rumia')?MELODY_RUMIA:MELODY_YOUMU; this.tempo=(char==='rumia')?146:155; this.oscillatorType=(char==='rumia')?'square':'sawtooth'; this.isPlaying=true; this.currentIndex=0; this.nextNoteTime=audioCtx.currentTime+0.1; this.scheduler(); }
        stop() { this.isPlaying=false; clearTimeout(this.timerID); }
        scheduler() { if(!this.isPlaying)return; while(this.nextNoteTime<audioCtx.currentTime+0.1){ this.playNote(this.melody[this.currentIndex],this.melody[this.currentIndex+1]); this.nextNoteTime+=this.melody[this.currentIndex+1]*(60.0/this.tempo); this.currentIndex=(this.currentIndex+2)%this.melody.length; } this.timerID=setTimeout(()=>this.scheduler(),25); }
        playNote(n,d) { if(n==='Rest'||!NOTES[n])return; const o=audioCtx.createOscillator(),g=audioCtx.createGain(),t=this.nextNoteTime,dur=(60.0/this.tempo)*d; o.type=this.oscillatorType; o.frequency.value=NOTES[n]; g.gain.setValueAtTime(0.01,t); g.gain.linearRampToValueAtTime(0.05,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur*0.9); o.connect(g); g.connect(masterGain); o.start(t); o.stop(t+dur); }
    }

    const SFX = {
        play: (type) => {
            const t = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            o.connect(g); g.connect(masterGain);
            if (type === 'shoot') { o.frequency.setValueAtTime(600, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.1); o.start(); o.stop(t+0.1); }
            else if (type === 'slash') { o.type='sawtooth'; o.frequency.value=100; g.gain.setValueAtTime(0.1,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.1); o.start(); o.stop(t+0.1); }
            else if (type === 'hit') { o.type='square'; o.frequency.setValueAtTime(150, t); o.frequency.exponentialRampToValueAtTime(50, t+0.05); g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.05); o.start(); o.stop(t+0.05); }
            else if (type === 'ult') { o.type='sawtooth'; o.frequency.setValueAtTime(50, t); o.frequency.linearRampToValueAtTime(800, t+1.0); g.gain.setValueAtTime(0.5, t); g.gain.linearRampToValueAtTime(0, t+1.0); o.start(); o.stop(t+1.0); }
            else if (type === 'kill') { o.type='sine'; o.frequency.setValueAtTime(800, t); o.frequency.linearRampToValueAtTime(1200, t+0.1); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.1); o.start(); o.stop(t+0.1); }
        }
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgmPlayer = new MusicPlayer();
    let screenShake = 0;

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();
    function initAudio() { if(!audioCtx){ audioCtx=new AudioCtx(); masterGain=audioCtx.createGain(); masterGain.gain.value=0.3; masterGain.connect(audioCtx.destination); } if(audioCtx.state==='suspended')audioCtx.resume(); }

    const GAME_CONFIG = { 
        initialHp: 10, 
        rumiaSpeed: 4, 
        youmuSpeed: 4.5,
        baseEnemyHp: 30 
    };

    const UPGRADE_POOL = [
        { id: 'penetrate', name: '穿透弹', req: 'rumia', type: '强化', desc: '子弹可穿透额外 1 个单位。', apply: (p) => p.penetration++ },
        { id: 'vuln', name: '黑暗侵蚀', req: 'rumia', type: '特效', desc: 'DoT伤害增加 20% 易伤效果。', apply: (p) => p.vulnPercent += 0.2 },
        { id: 'explode', name: '暗爆', req: 'rumia', type: '特效', desc: '子弹命中造成小范围爆炸。', apply: (p) => p.explode = true },
        { id: 'sword_intent', name: '剑意', req: 'youmu', type: '范围', desc: '剑气波数量增加 (顺时针+45°)。', apply: (p) => p.waveCount++ },
        { id: 'blade_soul', name: '刀魂', req: 'youmu', type: '攻击', desc: '斩击伤害提升 30%。', apply: (p) => p.damage = Math.floor(p.damage * 1.3) },
        { id: 'speed', name: '妖怪步伐', req: 'all', type: '速度', desc: '移动速度提升 10%。', apply: (p) => p.speed *= 1.1 },
        { id: 'heal', name: '紧急包扎', req: 'all', type: '恢复', desc: '恢复 3 点生命值。', apply: (p) => p.hp = Math.min(p.hp + 3, p.maxHp) }
    ];

    let gameState = {
        isRunning: false, isPaused: false, timeScale: 1.0, score: 0, 
        frameCount: 0, level: 1, exp: 0, expNext: 100, startTime: 0,
        totalEnemiesSpawned: 0, // 新增：总生成数
        enemies: [], bullets: [], slashes: [], dmgTexts: [], items: [], keys: {}, 
        charType: 'rumia', player: null, globalFreeze: 0
    };

    class Player {
        constructor(type) {
            this.type = type;
            this.x = canvas.width/2; this.y = canvas.height/2;
            this.hp = GAME_CONFIG.initialHp; this.maxHp = GAME_CONFIG.initialHp;
            this.radius = 15;
            this.speed = type === 'rumia' ? GAME_CONFIG.rumiaSpeed : GAME_CONFIG.youmuSpeed;
            
            this.gauge = 0; this.maxGauge = 100;
            
            // 露米娅
            this.rumiaMode = false; this.rumiaTimer = 0;
            this.atkInterval = 60;
            this.damage = type === 'rumia' ? 10 : 50; // 妖梦伤害改为 50
            this.dotDmg = 2; this.penetration = 0; this.vulnPercent = 0; this.explode = false;
            this.jCd = 0; this.modeKillCount = 0;

            // 妖梦
            this.youmuTimer = 0; this.swordWaveMode = false; this.waveCount = 2;
            this.dashState = 0; this.dashTarget = {x:0, y:0}; this.invincible = 0;
            this.atkTimer = 0; this.facingAngle = 0;
        }

        update() {
            let dx=0, dy=0;
            if(gameState.keys['KeyW']||gameState.keys['ArrowUp']) dy-=1;
            if(gameState.keys['KeyS']||gameState.keys['ArrowDown']) dy+=1;
            if(gameState.keys['KeyA']||gameState.keys['ArrowLeft']) dx-=1;
            if(gameState.keys['KeyD']||gameState.keys['ArrowRight']) dx+=1;
            
            let moveSpeed = this.speed;
            if(this.dashState > 0) moveSpeed = 0;
            
            if((dx!==0||dy!==0) && this.dashState <= 0) {
                const len = Math.hypot(dx, dy);
                this.x += (dx/len) * moveSpeed;
                this.y += (dy/len) * moveSpeed;
            }
            
            if(this.type === 'youmu') {
                if(dx===0 && dy===0) this.gauge = Math.min(100, this.gauge + 0.05);
                else this.gauge = Math.max(0, this.gauge - 0.1);

                const nearest = findNearestEnemy(this.x, this.y);
                if(nearest) this.facingAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                else if (dx!==0||dy!==0) this.facingAngle = Math.atan2(dy, dx);
            } else {
                if(dx!==0||dy!==0) this.facingAngle = Math.atan2(dy, dx);
            }

            this.x = Math.max(20, Math.min(canvas.width-20, this.x));
            this.y = Math.max(20, Math.min(canvas.height-20, this.y));
            
            if(this.jCd > 0) this.jCd--;
            if(this.invincible > 0) this.invincible--;
            
            // 妖梦被动反击/突进状态结束后的恢复
            if(this.dashState > 0) {
                this.dashState--;
                this.x += (this.dashTarget.x - this.x) * 0.2;
                this.y += (this.dashTarget.y - this.y) * 0.2;
                createSlash(this.x, this.y, 0, Math.PI*2, 80, this.damage*2, 2, false);
                
                if(this.dashState <= 0) {
                    gameState.timeScale = 1.0; // 恢复时间
                    document.getElementById('ult-text').style.opacity = 0;
                }
            }

            if(this.type === 'rumia' && this.rumiaMode) {
                this.rumiaTimer--;
                if(this.rumiaTimer % 5 === 0) {
                    createSlash(this.x, this.y, 0, Math.PI*2, 150, this.damage * 0.5, 2, false);
                    ctx.save(); ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.arc(this.x, this.y, 150, 0, Math.PI*2); ctx.fill(); ctx.restore();
                }
                if(this.rumiaTimer <= 0) { this.rumiaMode = false; this.atkTimer = 0; }
            }
            
            if(this.type === 'youmu' && this.youmuTimer > 0) {
                this.youmuTimer--;
                if(this.youmuTimer <= 0) { gameState.timeScale = 1.0; this.swordWaveMode = false; this.gauge = 0; }
            }

            if(this.dashState <= 0) {
                if(this.type === 'rumia' && this.rumiaMode) {}
                else {
                    if(this.atkTimer > 0) this.atkTimer--;
                    else { this.attack(); this.atkTimer = this.atkInterval; }
                }
            }

            if(this.type === 'rumia' && this.gauge >= 100 && !this.rumiaMode) {
                this.gauge = 0; this.rumiaMode = true; this.rumiaTimer = 600; this.modeKillCount = 0;
                createFloatingText(this.x, this.y - 40, "DARKNESS MODE!", "red");
            }
        }

        attack() {
            if(this.type === 'rumia') {
                const t = findNearestEnemy(this.x, this.y);
                if(t) {
                    SFX.play('shoot');
                    const a = Math.atan2(t.y-this.y, t.x-this.x);
                    gameState.bullets.push(new Bullet(this.x, this.y, a, this.penetration, this.dotDmg, this.vulnPercent, this.explode));
                }
            } else {
                SFX.play('slash');
                if(this.swordWaveMode) {
                    const startAng = this.facingAngle - Math.PI/4;
                    for(let i=0; i<this.waveCount; i++) {
                        const ang = startAng + (i * (Math.PI/4));
                        gameState.bullets.push(new Bullet(this.x, this.y, ang, 99, 0, 0, false, true));
                    }
                } else {
                    createSlash(this.x, this.y, this.facingAngle - Math.PI/2, this.facingAngle + Math.PI/2, 100, this.damage, 10, true);
                }
            }
        }

        // 妖梦受伤触发被动 (复刻旧版逻辑)
        triggerPassive(e) {
            gameState.timeScale = 0.1; // 极慢
            this.dashState = 60; // 1秒(60帧)
            this.invincible = 60;
            
            // 计算向敌人突进的位置 (1/3屏幕)
            const angle = Math.atan2(e.y - this.y, e.x - this.x);
            const dist = Math.min(canvas.width, canvas.height) * 0.33;
            this.dashTarget = { x: this.x + Math.cos(angle) * dist, y: this.y + Math.sin(angle) * dist };

            // 显示文字
            const ut = document.getElementById('ult-text');
            ut.innerText = "人鬼「未来永劫斩」";
            ut.style.opacity = 1;
            ut.style.transform = 'translate(-50%, -50%) scale(1.2)';
            setTimeout(()=>ut.style.transform='translate(-50%,-50%) scale(1)',100);
            
            SFX.play('ult');
        }

        handleSkill() {
            if(this.type === 'rumia') {
                if(this.rumiaMode) return;
                if(this.gauge >= 20 && this.jCd <= 0) {
                    this.gauge -= 20; this.jCd = 600;
                    createSlash(this.x, this.y, this.facingAngle - Math.PI/3, this.facingAngle + Math.PI/3, 200, 9999, 15, true);
                    createFloatingText(this.x, this.y-40, "CONSUME!", "red");
                }
            } else {
                if(this.youmuTimer > 0) return;
                if(this.gauge >= 30 && this.gauge < 60) {
                    this.gauge = 0; this.dashState = 20; this.invincible = 20;
                    const t = findNearestEnemy(this.x, this.y);
                    const angle = t ? Math.atan2(t.y-this.y, t.x-this.x) : this.facingAngle;
                    this.dashTarget = { x: this.x + Math.cos(angle)*200, y: this.y + Math.sin(angle)*200 };
                    SFX.play('slash');
                } else if (this.gauge >= 60 && this.gauge < 100) {
                    this.youmuTimer = 1200; this.swordWaveMode = true; gameState.timeScale = 0.2;
                    createFloatingText(this.x, this.y-40, "MYON TIME!", "cyan");
                } else if (this.gauge >= 99) {
                    this.gauge = 0; triggerGlobalKill();
                }
            }
        }
    }

    class Bullet {
        constructor(x, y, ang, pen, dot, vuln, explode, isWave=false) {
            this.x = x; this.y = y; this.speed = isWave ? 10 : 7;
            this.vx = Math.cos(ang) * this.speed; this.vy = Math.sin(ang) * this.speed;
            this.life = 100; this.r = isWave ? 10 : 6; this.pen = pen; this.hitList = [];
            this.dot = dot; this.vuln = vuln; this.explode = explode; this.isWave = isWave;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life--; }
        draw() {
            if(this.isWave) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.vy, this.vx));
                ctx.fillStyle = "rgba(200,255,255,0.8)";
                ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.fill(); ctx.restore();
            } else {
                ctx.fillStyle = "black"; ctx.strokeStyle = "red"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            }
        }
    }

    class Slash {
        constructor(x,y,s,e,r,d,dur, render=true){
            this.x=x;this.y=y;this.s=s;this.e=e;this.r=r;this.d=d;this.l=dur;this.ml=dur;this.render=render;
            this.processedEnemies = []; this.killCount = 0; this.checkHit();
        }
        checkHit() {
            for(let e of gameState.enemies) {
                if(this.processedEnemies.includes(e)) continue;
                if(Math.hypot(e.x-this.x, e.y-this.y) < this.r + e.radius) {
                    const ang = Math.atan2(e.y-this.y, e.x-this.x);
                    let angleDiff = ang - (this.s + (this.e-this.s)/2);
                    while(angleDiff <= -Math.PI) angleDiff += Math.PI*2;
                    while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                    if(Math.abs(this.e - this.s) > 6 || Math.abs(angleDiff) < (this.e - this.s)/2 + 0.5) {
                        e.takeDamage(this.d); this.processedEnemies.push(e);
                        if(e.hp <= 0) this.killCount++;
                    }
                }
            }
            if(gameState.player.type === 'rumia') {
                gameState.player.modeKillCount += this.killCount;
                while(gameState.player.modeKillCount >= 2) {
                    gameState.player.hp = Math.min(gameState.player.hp+1, gameState.player.maxHp);
                    gameState.player.modeKillCount -= 2;
                    createFloatingText(gameState.player.x, gameState.player.y, "+1 HP", "green");
                }
            }
        }
        update(){ this.l--; if(this.l % 5 === 0) this.checkHit(); }
        draw(){
            if(!this.render) return;
            ctx.save(); ctx.translate(this.x,this.y);
            ctx.globalAlpha = Math.max(0, this.l/this.ml);
            ctx.fillStyle=gameState.charType==='rumia'?"rgba(200,0,0,0.5)":"rgba(200,255,255,0.5)";
            ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,this.r,this.s,this.e); ctx.fill();
            ctx.restore();
        }
    }

    class Enemy {
        constructor() {
            const r=Math.random();
            if(r<0.25){this.x=Math.random()*canvas.width;this.y=-30;}else if(r<0.5){this.x=canvas.width+30;this.y=Math.random()*canvas.height;}
            else if(r<0.75){this.x=Math.random()*canvas.width;this.y=canvas.height+30;}else{this.x=-30;this.y=Math.random()*canvas.height;}
            
            // 敌人成长：每生成300个，血量+20
            const hpBonus = Math.floor(gameState.totalEnemiesSpawned / 300) * 20;
            this.maxHp = GAME_CONFIG.baseEnemyHp + hpBonus;
            this.hp = this.maxHp;
            
            this.radius=12; this.spd=1.0; this.c=`hsl(${Math.random()*360},70%,60%)`; 
            this.dotTicks=0; this.dotDmg=0; this.vuln=1.0;
        }
        update(){
            if(gameState.globalFreeze > 0) return;
            const a=Math.atan2(gameState.player.y-this.y, gameState.player.x-this.x);
            this.x+=Math.cos(a)*this.spd*gameState.timeScale; 
            this.y+=Math.sin(a)*this.spd*gameState.timeScale;
            if(this.dotTicks>0) {
                if(gameState.frameCount % 60 === 0) { this.takeDamage(this.dotDmg, true); this.dotTicks--; }
            }
        }
        takeDamage(amt, isDot=false) {
            const finalDmg = amt * this.vuln;
            this.hp -= finalDmg;
            createFloatingText(this.x, this.y, Math.floor(finalDmg), isDot?"purple":"white");
            if(gameState.player.type === 'rumia' && !isDot && !gameState.player.rumiaMode) {
                gameState.player.gauge = Math.min(100, gameState.player.gauge + 1);
            }
            if(this.hp<=0) this.die();
        }
        die() {
            const i=gameState.enemies.indexOf(this);
            if(i>-1){
                gameState.enemies.splice(i,1);
                gameState.score+=10; gameState.exp+=10;
                gameState.items.push({x:this.x,y:this.y});
                SFX.play('kill');
                if(gameState.exp>=gameState.expNext) triggerLevelUp();
            }
        }
        draw(){
            ctx.fillStyle = this.dotTicks > 0 ? "#550000" : this.c;
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="red"; ctx.fillRect(this.x-10, this.y-20, 20, 4);
            ctx.fillStyle="#00ff00"; ctx.fillRect(this.x-10, this.y-20, 20*(this.hp/this.maxHp), 4);
        }
    }

    function findNearestEnemy(x,y){let n=null,m=Infinity;gameState.enemies.forEach(e=>{const d=(e.x-x)**2+(e.y-y)**2;if(d<m){m=d;n=e;}});return n;}
    function createSlash(x,y,s,e,r,d,du,ren){gameState.slashes.push(new Slash(x,y,s,e,r,d,du,ren));}
    function createFloatingText(x,y,t,c){gameState.dmgTexts.push({x,y,t,c,l:40});}
    
    function triggerGlobalKill() {
        gameState.globalFreeze = 60; SFX.play('ult');
        const overlay = document.getElementById('flash-overlay'); overlay.style.opacity = 1;
        const ultText = document.getElementById('ult-text'); ultText.innerText = "人鬼「未来永劫斩」";
        ultText.style.opacity = 1; ultText.style.transform = 'translate(-50%, -50%) scale(1.5)';
        setTimeout(() => {
            overlay.style.opacity = 0; ultText.style.opacity = 0; ultText.style.transform = 'translate(-50%, -50%) scale(1)';
            gameState.enemies.forEach(e => { gameState.score+=10; gameState.exp+=10; gameState.items.push({x:e.x, y:e.y}); });
            gameState.enemies = [];
            gameState.items.forEach(it => { it.magnet = true; });
            if(gameState.exp>=gameState.expNext) triggerLevelUp();
        }, 1000);
    }

    function checkCollisions(){
        const p=gameState.player;
        for(let i=gameState.bullets.length-1; i>=0; i--){
            let b=gameState.bullets[i]; let remove = false;
            for(let e of gameState.enemies){
                if(b.hitList.includes(e)) continue;
                if(Math.hypot(b.x-e.x, b.y-e.y) < b.r+e.radius){
                    let dmg = p.damage; 
                    if(p.type === 'rumia') {
                        e.dotTicks += 10; e.dotDmg = b.dot;
                        if(b.vuln > 0) e.vuln = 1.0 + b.vuln;
                        if(b.explode) createSlash(b.x, b.y, 0, Math.PI*2, 40, p.damage*0.5, 5, true);
                    }
                    e.takeDamage(dmg); b.hitList.push(e);
                    if(b.hitList.length > b.pen) { remove = true; break; }
                }
            }
            if(b.life<=0 || remove) gameState.bullets.splice(i,1);
        }

        for(let e of gameState.enemies){
            if(p.invincible>0 || gameState.globalFreeze > 0) continue;
            if(Math.hypot(p.x-e.x, p.y-e.y) < p.radius+e.radius){
                p.hp-=1; p.invincible=30; 
                screenShake = 10; document.getElementById('damage-overlay').style.opacity = 1;
                setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 200);
                SFX.play('hit');
                
                // 妖梦被动触发
                if(p.type === 'youmu') {
                    p.triggerPassive(e);
                }

                if(p.hp<=0) endGame();
            }
        }
        
        for(let i=gameState.items.length-1;i>=0;i--){
            let it=gameState.items[i];
            let dist = Math.hypot(p.x-it.x,p.y-it.y);
            if(it.magnet || dist < 100){ it.x+=(p.x-it.x)*0.2; it.y+=(p.y-it.y)*0.2; }
            if(dist < p.radius+10){
                gameState.items.splice(i,1); gameState.exp += 10;
                if(gameState.exp>=gameState.expNext) triggerLevelUp();
            }
        }
    }

    function gameLoop(){
        if(!gameState.isRunning||gameState.isPaused)return;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        if(screenShake>0) { ctx.save(); ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake); screenShake *= 0.9; if(screenShake<0.5) screenShake=0; }
        ctx.strokeStyle="#333";ctx.lineWidth=1;
        for(let i=0;i<canvas.width;i+=50){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,canvas.height);ctx.stroke();}
        for(let i=0;i<canvas.height;i+=50){ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(canvas.width,i);ctx.stroke();}

        if(gameState.globalFreeze > 0) gameState.globalFreeze--;
        else gameState.frameCount++;

        if(gameState.frameCount%60===0 && gameState.globalFreeze <= 0) {
            gameState.enemies.push(new Enemy());
            gameState.totalEnemiesSpawned++; // 增加总数
        }

        gameState.player.update();
        gameState.bullets.forEach((b,i)=>b.update());
        for(let i=gameState.slashes.length-1; i>=0; i--){ let s=gameState.slashes[i]; s.update(); if(s.l<=0) gameState.slashes.splice(i,1); }
        gameState.enemies.forEach(e=>e.update());
        gameState.dmgTexts.forEach((t,i)=>{t.y-=1;t.l--;if(t.l<=0)gameState.dmgTexts.splice(i,1);});

        checkCollisions();

        ctx.fillStyle="cyan";gameState.items.forEach(it=>ctx.fillRect(it.x-3,it.y-3,6,6));
        gameState.enemies.forEach(e=>e.draw());
        gameState.bullets.forEach(b=>b.draw());
        gameState.slashes.forEach(s=>s.draw());
        
        const p = gameState.player;
        ctx.save(); ctx.translate(p.x, p.y);
        ctx.fillStyle = "#333"; ctx.fillRect(-20, -35, 40, 6);
        if(p.type === 'rumia') ctx.fillStyle = "red"; 
        else ctx.fillStyle = "cyan";
        ctx.fillRect(-20, -35, 40 * (p.gauge/100), 6);
        if(p.type === 'youmu') { ctx.fillStyle="white"; ctx.fillRect(-20+12,-35,1,6); ctx.fillRect(-20+24,-35,1,6); }

        if(p.invincible>0 && Math.floor(Date.now()/50)%2===0) ctx.globalAlpha=0.5;
        if(p.type==='rumia') {
            ctx.fillStyle=p.rumiaMode?"#550000":"black"; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="#ffaaaa"; ctx.beginPath(); ctx.arc(0,-10,12,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="red"; ctx.fillRect(-15,-20,8,8); ctx.fillRect(7,-20,8,8);
        } else {
            ctx.fillStyle=p.swordWaveMode?"#008844":"#004422"; ctx.beginPath(); ctx.arc(0,5,14,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="#eeeeee"; ctx.beginPath(); ctx.arc(0,-8,11,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="black"; ctx.fillRect(-12,-12,24,4);
            ctx.strokeStyle="#ddd"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(10,5);
            ctx.lineTo(10+Math.cos(p.facingAngle)*25, 5+Math.sin(p.facingAngle)*25); ctx.stroke();
        }
        ctx.restore();

        gameState.dmgTexts.forEach(t=>{ctx.fillStyle=t.c;ctx.font="bold 16px Arial";ctx.fillText(t.t,t.x,t.y);});
        if(screenShake>0) ctx.restore();
        updateUI();
        requestAnimationFrame(gameLoop);
    }

    function selectCharacter(type){ initAudio(); gameState.charType=type; bgmPlayer.play(type); document.getElementById('char-select-screen').classList.add('hidden'); startGame(); }
    function startGame(){ gameState.player=new Player(gameState.charType); gameState.enemies=[];gameState.bullets=[];gameState.slashes=[];gameState.items=[]; gameState.score=0;gameState.level=1;gameState.exp=0;gameState.expNext=100; gameState.totalEnemiesSpawned=0; gameState.startTime=Date.now(); gameState.isRunning=true;gameState.isPaused=false; document.getElementById('game-over-screen').classList.add('hidden'); requestAnimationFrame(gameLoop); }
    function triggerLevelUp(){ gameState.isPaused=true; gameState.level++;gameState.exp-=gameState.expNext;gameState.expNext=Math.floor(gameState.expNext*1.4); const c=document.getElementById('upgrade-container');c.innerHTML=''; UPGRADE_POOL.filter(u=>u.req==='all'||u.req===gameState.charType).sort(()=>0.5-Math.random()).slice(0,3).forEach(opt=>{ const d=document.createElement('div');d.className='upgrade-card'; d.innerHTML=`<div style="font-size:12px;color:#888">${opt.type}</div><div style="font-size:18px;font-weight:bold;color:#ffcc00;margin:10px 0;">${opt.name}</div><div style="font-size:13px;color:#ccc">${opt.desc}</div>`; d.onclick=()=>{opt.apply(gameState.player);gameState.isPaused=false;document.getElementById('upgrade-screen').classList.add('hidden');requestAnimationFrame(gameLoop);}; c.appendChild(d); }); document.getElementById('upgrade-screen').classList.remove('hidden'); }
    function endGame(){ gameState.isRunning=false; bgmPlayer.stop(); document.getElementById('final-score').innerText=`Score: ${gameState.score}`; document.getElementById('game-over-screen').classList.remove('hidden'); }
    function updateUI(){ document.getElementById('score-display').innerText=`Score: ${gameState.score}`; document.getElementById('level-display').innerText=`Lv. ${gameState.level}`; document.getElementById('hp-text').innerText=`${Math.ceil(gameState.player.hp)}/${gameState.player.maxHp}`; document.getElementById('exp-bar').style.width=`${(gameState.exp/gameState.expNext)*100}%`; }
    window.addEventListener('keydown',e=>{ gameState.keys[e.code]=true; if(e.code==='KeyJ'&&gameState.isRunning&&!gameState.isPaused)gameState.player.handleSkill(); });
    window.addEventListener('keyup',e=>gameState.keys[e.code]=false);
</script>
</body>
</html>